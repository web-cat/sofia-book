<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Chapter 5: Apps with Multiple Screens</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="">

    <!-- Le styles -->
    <link rel="stylesheet" href="css/bootstrap.css" type="text/css"/>
    <link rel="stylesheet" href="css/bootstrap-responsive.css" type="text/css"/>
    <link rel="stylesheet" href="codemirror/lib/codemirror.css" type="text/css"/>
    <link rel="stylesheet" href="codemirror/theme/simple.css" type="text/css"/>
    <link rel="stylesheet" href="css/style.css" type="text/css"/>

    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="navbar navbar-fixed-top">
      <div class="navbar-inner">
        <div class="container">
          <a class="brand" href="index.html">Sofia</a>
          <div class="nav-collapse collapse">
            <ul class="nav">
              <li class="dropdown">
                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Chapters <b class="caret"></b></a>
                <ul class="dropdown-menu">
                  <li><a href="chapter1.html">1. Structure of an Android Project</a></li>
                  <li><a href="chapter2.html">2. Basic GUI-Driven Apps</a></li>
                  <li><a href="chapter3.html">3. Testing GUI Apps</a></li>
                  <li><a href="chapter4.html">4. Advanced Graphics</a></li>
                  <li class="active"><a href="chapter5.html">5. Apps with Multiple Screens</a></li>
                </ul>
              </li>
              <li><a href="http://sofia.cs.vt.edu/sofia-2114/api/reference">Sofia API</a></li>
            </ul>
          </div><!--/.nav-collapse -->
        </div>
      </div>
    </div>

    <div class="container">

      <!-- Main hero unit for a primary marketing message or call to action -->
      <div class="hero-unit">
        <h1>Apps with Multiple Screens</h1>
        <p class="lead">Creating apps with multiple screens and communicating information between them can be difficult on Android, but Sofia makes the process much easier.</p>
      </div>

      <h3>Jump to...</h3>
      <ol>
        <li><a href="#motivation">Motivation</a></li>
        <li><a href="#navigation-stack">The Navigation Stack</a></li>
        <li><a href="#manifest">Multiple Screens and the Android Manifest File</a></li>
        <li><a href="#display-screen">How to Display Another Screen</a></li>
        <li><a href="#pass-information">Passing Parameters to a New Screen</a></li>
        <li><a href="#return-information">Returning Information Back from a Screen</a></li>
        <li><a href="#manipulating-stack">Manipulating the Navigation Stack</a></li>
      </ol>


      <div class="page-header"><h2 id="motivation">Motivation</h2></div>

      <p>
        All of the examples that we've seen so far have been of apps that only had a single screen. For some small utilities this might be enough, but generally if we want to design apps that accomplish something more interesting, we need to break it up into multiple screens that serve different purposes.
      </p><p>
        For example, an e-mail app would have several different screens depending on the actions that the user would want to perform:
      </p>
      <ul>
        <li>A screen that displays a list of messages in a mailbox, such as the user's inbox</li>
        <li>A screen that displays the contents of a single message that the user wants to read</li>
        <li>A screen that allows the user to compose and send a new message</li>
        <li>A screen that allows the user to configure various e-mail settings, such as his or her accounts and signatures</li>
      </ul>
      <p>
        It would be inappropriate from a software design and a GUI design point of view to lump all of this functionality into a single screen class. What we need is a way to create multiple screens, navigate between them, and pass information between them as well.
      </p>


      <div class="page-header"><h2 id="navigation-stack">The Navigation Stack</h2></div>

      <p class="center">
        <img src="img/ch5/navigation-stack.png"/>
      </p>

      <p>
        Navigation in Android apps is based on a <span class="label label-info">stack</span> (called a <span class="label label-info">back stack</span> in the official Android documentation). Imagine that the <span class="label label-info">home screen</span> is always at the bottom of the stack. When you open an app from your launcher, one of its screens gets <span class="label label-info">pushed</span> onto the stack. You, the user, always see the screen that is currently at the top of the stack. If you click a button on that screen that opens another screen, then the new one is pushed onto the stack as well.
      </p><p>
        To leave a screen and go back to the previous one, you click the <span class="label label-info">Back</span> button on your device. This <span class="label label-info">pops</span> the navigation stack, destroys the current screen, and returns you to the one just before it. You can continue to go back in this way until you reach the home screen again.
      </p>


      <div class="page-header"><h2 id="manifest">Multiple Screens and the Android Manifest File</h2></div>

      <p>
        Recall that Android applications are composed of one or more <span class="label label-info">activities</span>, each of which represents a single screen in the application. Also recall that Sofia provides the <code class="link">sofia.app.Screen</code> class that 
      </p><p>

      </p>


      <div class="page-header"><h2 id="shape-types">Types of Shapes</h2></div>

      <p>
        Sofia contains a hierarchy of shape classes that use of polymorphism and method overriding to provide several types of shapes that have a common base class. All shapes in Sofia extend the abstract <code class="link">sofia.graphics.Shape</code> class, which maintains properties that all shapes have in common&mdash;their size and position, color, and rotation.
      </p><p>

      </p><p>
        The table below lists all of the concrete types of shapes that you can create and use in your own apps:
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Class</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code class="link">sofia.graphics.RectangleShape</code></td>
            <td>Displays a rectangle (or square, if the width and height are the same). This shape can be drawn as a hollow outline or a filled solid.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.OvalShape</code></td>
            <td>Displays an oval (or circle, if the width and height are the same). This shape can be drawn as a hollow outline or a filled solid.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.LineShape</code></td>
            <td>Displays a line between two points.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.ImageShape</code></td>
            <td>Displays an image from your application resources folder or from a file in the device's storage.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.TextShape</code></td>
            <td>A shape that renders a text string. You can use this shape class to create text displays among other graphics in your app, such as a scoreboard in a game.</td>
          </tr>
        </tbody>
      </table>

      <p>
        The various shape classes have a number of constructors that make it easy to create these shapes with different positions, sizes, and other required visual properties. Each type of shape is summarized below.
      </p>


      <h3>Rectangles</h3>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Constructor</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.RectangleShape#RectangleShape(float, float, float, float)</code></td>
            <td>Creates a rectangle from four coordinates, in the following order: the <i>x</i>-coordinate of the <em>left</em> side, the <i>y</i>-coordinate of the <em>top</em>, the <i>x</i>-coordinate of the <em>right</em> side, and the <i>y</i>-coordinate of the <em>bottom</em>.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.RectangleShape#RectangleShape(RectF)</code></td>
            <td>Creates a rectangle from a <code class="link">android.graphics.RectF</code> object, which is an object that encapsulates the left, top, right, and bottom coordinates of a rectangle.</td>
          </tr>
        </tbody>
      </table>


      <h3>Ovals</h3>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Constructor</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.OvalShape#OvalShape(float, float, float, float)</code></td>
            <td>Creates an oval from four coordinates, in the following order: the <i>x</i>-coordinate of the <em>center</em> of the oval, the <i>y</i>-coordinate of the <em>center</em> of the oval, the <em>horizontal radius</em>, and the <em>vertical radius</em>.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.OvalShape#OvalShape(float, float, float)</code></td>
            <td>Creates a <strong>circular</strong> oval from three coordinates, in the following order: the <i>x</i>-coordinate of the <em>center</em> of the oval, the <i>y</i>-coordinate of the <em>center</em> of the oval, and the <em>radius</em>.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.OvalShape#OvalShape(RectF)</code></td>
            <td>Creates an oval from a <code class="link">android.graphics.RectF</code> object, which is an object that encapsulates the left, top, right, and bottom coordinates of a rectangle. The oval that is created is the largest oval that would fit inside that rectangle (in other words, the width of the rectangle is its horizontal diameter and the height of the rectangle is its vertical diameter).</td>
          </tr>
        </tbody>
      </table>


      <h3>Lines</h3>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Constructor</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.LineShape#LineShape(float, float, float, float)</code></td>
            <td>Creates a line from four coordinates, in the following order: the <i>x</i>-coordinate of the first endpoint, the <i>y</i>-coordinate of the first endpoint, the <i>x</i>-coordinate of the second endpoint, and the <i>y</i>-coordinate of the second endpoint.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.LineShape#LineShape(RectF)</code></td>
            <td>Creates a line from a <code class="link">android.graphics.RectF</code> object, which is an object that encapsulates the left, top, right, and bottom coordinates of a rectangle. The endpoints of the line are (<i>left</i>, <i>top</i>) and (<i>right</i>, <i>bottom</i>).</td>
          </tr>
        </tbody>
      </table>


      <h3>Images</h3>

      <p>
        The <code class="link">sofia.graphics.ImageShape</code> class lets you display images from your app's resources on the screen.
      </p><p>
        Images are stored in one of the <code>res/drawable-*</code> folders in your Eclipse project. In the constructors below, you refer to the image using its filename without an extension. For example, if you have images named <code>res/drawable-*/dragon.png</code> in your project (where the <code>*</code> refers to any of the resolution identifiers like <code>hdpi</code>, <code>mdpi</code>, and so on), then you would pass in simply <code>"dragon"</code> and the image that most closely matches your device's screen resolution would be used.
      </p><p>
        When you create an <code>ImageShape</code>, you also provide the area on the screen that you want the image to occupy. The image will be stretched or shrunk in order to make it fit inside that area.
      </p><p>
        Images can also be shaded with a color by using the <code class="link">sofia.graphics.Shape#setColor(Color)</code> method.
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Constructor</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.ImageShape#ImageShape(String, float, float, float, float)</code></td>
            <td>Creates a new shape that will draw the image with the name specified by the <code>String</code> parameter. The image will be stretched or shrunk to fit in the area specified by the four <code>float</code> parameters.</td>
          </tr>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.ImageShape#ImageShape(String, RectF)</code></td>
            <td>Creates a new shape that will draw the image with the name specified by the <code>String</code> parameter. The image will be stretched or shrunk to fit in the area specified by the <code>RectF</code> parameter.</td>
          </tr>
        </tbody>
      </table>


      <h3>Text Shapes</h3>

      <p>
        The <code class="link">sofia.graphics.TextShape</code> class lets you display a text string on your screen. These can be used, for example, to incorporate information in a game like player's health or their current score.
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Constructor</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td style="width: 40%"><code class="link">sofia.graphics.TextShape#TextShape(String, float, float)</code></td>
            <td>Creates a new shape that will draw the text specified by the <code>String</code> parameter. The text will be anchored so that the top-left corner of the box containing the text is at the <i>x</i>- and <i>y</i>-coordinates indicated by the two <code>float</code> parameters.</td>
          </tr>
        </tbody>
      </table>


      <h3>Subclassing the Built-in Shapes</h3>

      <p>
        Even though they're objects, you should think of the shape classes provided by Sofia as primitive graphical constructs and not part of a richer data model. Imagine that you're writing an <em>Angry Birds</em> knock-off, and you need shapes to represent the piggies and the birds. Those would be drawn on the screen using <code>ImageShape</code> objects, but it would be bad design to have your program logic manipulate <code>ImageShape</code> objects directly.
      </p><p>
        Instead, you can <strong>extend</strong> the built-in shapes to make them specific to your app and customize them by adding your own logic. For example, you could create your own <code>Piggy</code> class:
      </p>

<pre>
public class Piggy extends ImageShape
{
    public Piggy(float left, float top, float right, float bottom)
    {
        super("piggy", left, top, right, bottom);
    }
}
</pre>

      <p>
        Even though <code>Piggy</code> extends <code>ImageShape</code>, notice that we have given it a constructor that only takes the bounds of the shape and not the image that it should use. This is because we want all instances of <code>Piggy</code> to use the same fixed image (in this case, the <code>"piggy"</code> drawable resource). We achieve this by calling the <code>super</code> constructor and passing it the additional parameter.
      </p><p>
        Now that we have a custom class to represent piggies in our game, we can add additional piggy-specific behavior to the class. For example, when a piggy gets hit, maybe its health drops and it changes its appearance. Here's an example:
      </p>

<pre>
public class Piggy extends ImageShape
{
    // How much health the piggy has left.
    private int health;

    public Piggy(float left, float top, float right, float bottom)
    {
        super("piggy", left, top, right, bottom);

        // Let a piggy get hit twice before dying.
        health = 2;
    }

    public void gotHit()
    {
        health--;

        if (health == 1)
        {
            // Make the piggy appear beaten up.
            setImage("piggy_weak");
        }
        else
        {
            // Remove the piggy from the screen, "killing" it.
            remove();
        }
    }
}
</pre>

      <div class="page-header"><h2 id="colors">Colors</h2></div>

      <img class="figure pull-right" src="img/additive-color.png"/>

      <p>
        Sofia provides a <code class="link">sofia.graphics.Color</code> class that allows you to create objects that represent colors for shapes and other purposes.
      </p><p>
        On computer displays, colors are formed by mixing the three primary color components&mdash;<strong style="color: red">red</strong>, <strong style="color: green">green</strong>, and <strong style="color: blue">blue</strong> (collectively known as <strong>RGB</strong>). Each of these components is represented by an integer between 0 and 255, where 0 means that the component is absent from the color and 255 means the component is contributing maximally to the color. So for example, a color with a red component of 255 and green and blue components of 0 would represent the brightest shade of red that your display can produce. If you changed red to be 128, then it would be a shade of red with 50% brightness.
      </p><p>
        The figure to the right shows the colors that could be created by mixing different combinations of the primary colors at full strength. For example, red and green combine to form yellow. The absence of all three color components produces black, and the full presence of every color component produces white. When each of the RGB values is the same, shades of gray are produced.
      </p><p>
        In addition to the red, green, and blue components, colors also contain an <strong>alpha</strong> component that describes how <em>transparent</em> the color is when it is drawn on the screen. Like the other three components, alpha is an integer value between 0 and 255, where 0 means that the color is completely transparent (invisible) and 255 means that the color is completely opaque (nothing behind it would show through). By using alpha in your drawings, you can create some interesting blending effects.
      </p>

      <div class="alert alert-info">
        The RGB color scheme is called an <strong>additive color</strong> scheme because different colors of light are added together to form new colors. The stronger each component is, the brighter the color will be. This is the opposite of the <strong>subtractive color</strong> scheme that you grew up with as a child, which had the primary colors red, yellow, and blue. This scheme is subtractive because the various pigments <em>absorb</em> light, so mixing them produces darker colors instead of lighter ones.
      </div>

      <div class="figure pull-right">
        <div>
          <div style="background-color: #FFB6C1" class="swatch" rel="tooltip" title="Color.lightPink"></div>
          <div style="background-color: #FFC0CB" class="swatch" rel="tooltip" title="Color.pink"></div>
          <div style="background-color: #DC143C" class="swatch" rel="tooltip" title="Color.crimson"></div>
          <div style="background-color: #FFF0F5" class="swatch" rel="tooltip" title="Color.lavenderBlush"></div>
          <div style="background-color: #DB7093" class="swatch" rel="tooltip" title="Color.paleVioletRed"></div>
          <div style="background-color: #FF69B4" class="swatch" rel="tooltip" title="Color.hotPink"></div>
          <div style="background-color: #FF1493" class="swatch" rel="tooltip" title="Color.deepPink"></div>
          <div style="background-color: #C71585" class="swatch" rel="tooltip" title="Color.mediumVioletRed"></div>
          <div style="background-color: #DA70D6" class="swatch" rel="tooltip" title="Color.orchid"></div>
          <div style="background-color: #D8BFD8" class="swatch" rel="tooltip" title="Color.thistle"></div>
          <div style="background-color: #DDA0DD" class="swatch" rel="tooltip" title="Color.plum"></div>
          <div style="background-color: #EE82EE" class="swatch" rel="tooltip" title="Color.violet"></div>
          <div style="background-color: #FF00FF" class="swatch" rel="tooltip" title="Color.magenta"></div>
          <div style="background-color: #FF00FF" class="swatch" rel="tooltip" title="Color.fuchsia"></div>
          <div style="background-color: #8B008B" class="swatch" rel="tooltip" title="Color.darkMagenta"></div>
          <div style="background-color: #800080" class="swatch" rel="tooltip" title="Color.purple"></div>
          <div style="background-color: #BA55D3" class="swatch" rel="tooltip" title="Color.mediumOrchid"></div>
          <div style="background-color: #9400D3" class="swatch" rel="tooltip" title="Color.darkViolet"></div>
          <div style="background-color: #9932CC" class="swatch" rel="tooltip" title="Color.darkOrchid"></div>
          <div style="background-color: #4B0082" class="swatch" rel="tooltip" title="Color.indigo"></div>
        </div><div>
          <div style="background-color: #8A2BE2" class="swatch" rel="tooltip" title="Color.blueViolet"></div>
          <div style="background-color: #9370DB" class="swatch" rel="tooltip" title="Color.mediumPurple"></div>
          <div style="background-color: #7B68EE" class="swatch" rel="tooltip" title="Color.mediumSlateBlue"></div>
          <div style="background-color: #6A5ACD" class="swatch" rel="tooltip" title="Color.slateBlue"></div>
          <div style="background-color: #483D8B" class="swatch" rel="tooltip" title="Color.darkSlateBlue"></div>
          <div style="background-color: #E6E6FA" class="swatch" rel="tooltip" title="Color.lavender"></div>
          <div style="background-color: #F8F8FF" class="swatch" rel="tooltip" title="Color.ghostWhite"></div>
          <div style="background-color: #0000FF" class="swatch" rel="tooltip" title="Color.blue"></div>
          <div style="background-color: #0000CD" class="swatch" rel="tooltip" title="Color.mediumBlue"></div>
          <div style="background-color: #191970" class="swatch" rel="tooltip" title="Color.midnightBlue"></div>
          <div style="background-color: #00008B" class="swatch" rel="tooltip" title="Color.darkBlue"></div>
          <div style="background-color: #000080" class="swatch" rel="tooltip" title="Color.navy"></div>
          <div style="background-color: #4169E1" class="swatch" rel="tooltip" title="Color.royalBlue"></div>
          <div style="background-color: #6495ED" class="swatch" rel="tooltip" title="Color.cornflowerBlue"></div>
          <div style="background-color: #B0C4DE" class="swatch" rel="tooltip" title="Color.lightSteelBlue"></div>
          <div style="background-color: #778899" class="swatch" rel="tooltip" title="Color.lightSlateGray"></div>
          <div style="background-color: #708090" class="swatch" rel="tooltip" title="Color.slateGray"></div>
          <div style="background-color: #1E90FF" class="swatch" rel="tooltip" title="Color.dodgerBlue"></div>
          <div style="background-color: #F0F8FF" class="swatch" rel="tooltip" title="Color.aliceBlue"></div>
          <div style="background-color: #4682B4" class="swatch" rel="tooltip" title="Color.steelBlue"></div>
        </div><div>
          <div style="background-color: #87CEFA" class="swatch" rel="tooltip" title="Color.lightSkyBlue"></div>
          <div style="background-color: #87CEEB" class="swatch" rel="tooltip" title="Color.skyBlue"></div>
          <div style="background-color: #00BFFF" class="swatch" rel="tooltip" title="Color.deepSkyBlue"></div>
          <div style="background-color: #ADD8E6" class="swatch" rel="tooltip" title="Color.lightBlue"></div>
          <div style="background-color: #B0E0E6" class="swatch" rel="tooltip" title="Color.powderBlue"></div>
          <div style="background-color: #5F9EA0" class="swatch" rel="tooltip" title="Color.cadetBlue"></div>
          <div style="background-color: #F0FFFF" class="swatch" rel="tooltip" title="Color.azure"></div>
          <div style="background-color: #E0FFFF" class="swatch" rel="tooltip" title="Color.lightCyan"></div>
          <div style="background-color: #AFEEEE" class="swatch" rel="tooltip" title="Color.paleTurquoise"></div>
          <div style="background-color: #00FFFF" class="swatch" rel="tooltip" title="Color.cyan"></div>
          <div style="background-color: #00FFFF" class="swatch" rel="tooltip" title="Color.aqua"></div>
          <div style="background-color: #00CED1" class="swatch" rel="tooltip" title="Color.darkTurquoise"></div>
          <div style="background-color: #2F4F4F" class="swatch" rel="tooltip" title="Color.darkSlateGray"></div>
          <div style="background-color: #008B8B" class="swatch" rel="tooltip" title="Color.darkCyan"></div>
          <div style="background-color: #008080" class="swatch" rel="tooltip" title="Color.teal"></div>
          <div style="background-color: #48D1CC" class="swatch" rel="tooltip" title="Color.mediumTurquoise"></div>
          <div style="background-color: #20B2AA" class="swatch" rel="tooltip" title="Color.lightSeaGreen"></div>
          <div style="background-color: #40E0D0" class="swatch" rel="tooltip" title="Color.turquoise"></div>
          <div style="background-color: #7FFFD4" class="swatch" rel="tooltip" title="Color.aquamarine"></div>
          <div style="background-color: #66CDAA" class="swatch" rel="tooltip" title="Color.mediumAquamarine"></div>
        </div><div>
          <div style="background-color: #00FA9A" class="swatch" rel="tooltip" title="Color.mediumSpringGreen"></div>
          <div style="background-color: #F5FFFA" class="swatch" rel="tooltip" title="Color.mintCream"></div>
          <div style="background-color: #00FF7F" class="swatch" rel="tooltip" title="Color.springGreen"></div>
          <div style="background-color: #3CB371" class="swatch" rel="tooltip" title="Color.mediumSeaGreen"></div>
          <div style="background-color: #2E8B57" class="swatch" rel="tooltip" title="Color.seaGreen"></div>
          <div style="background-color: #F0FFF0" class="swatch" rel="tooltip" title="Color.honeydew"></div>
          <div style="background-color: #90EE90" class="swatch" rel="tooltip" title="Color.lightGreen"></div>
          <div style="background-color: #98FB98" class="swatch" rel="tooltip" title="Color.paleGreen"></div>
          <div style="background-color: #8FBC8F" class="swatch" rel="tooltip" title="Color.darkSeaGreen"></div>
          <div style="background-color: #32CD32" class="swatch" rel="tooltip" title="Color.limeGreen"></div>
          <div style="background-color: #00FF00" class="swatch" rel="tooltip" title="Color.lime"></div>
          <div style="background-color: #228B22" class="swatch" rel="tooltip" title="Color.forestGreen"></div>
          <div style="background-color: #008000" class="swatch" rel="tooltip" title="Color.green"></div>
          <div style="background-color: #006400" class="swatch" rel="tooltip" title="Color.darkGreen"></div>
          <div style="background-color: #7FFF00" class="swatch" rel="tooltip" title="Color.chartreuse"></div>
          <div style="background-color: #7CFC00" class="swatch" rel="tooltip" title="Color.lawnGreen"></div>
          <div style="background-color: #ADFF2F" class="swatch" rel="tooltip" title="Color.greenYellow"></div>
          <div style="background-color: #556B2F" class="swatch" rel="tooltip" title="Color.darkOliveGreen"></div>
          <div style="background-color: #9ACD32" class="swatch" rel="tooltip" title="Color.yellowGreen"></div>
          <div style="background-color: #6B8E23" class="swatch" rel="tooltip" title="Color.oliveDrab"></div>
        </div><div>
          <div style="background-color: #F5F5DC" class="swatch" rel="tooltip" title="Color.beige"></div>
          <div style="background-color: #FAFAD2" class="swatch" rel="tooltip" title="Color.lightGoldenrodYellow"></div>
          <div style="background-color: #FFFFF0" class="swatch" rel="tooltip" title="Color.ivory"></div>
          <div style="background-color: #FFFFE0" class="swatch" rel="tooltip" title="Color.lightYellow"></div>
          <div style="background-color: #FFFF00" class="swatch" rel="tooltip" title="Color.yellow"></div>
          <div style="background-color: #808000" class="swatch" rel="tooltip" title="Color.olive"></div>
          <div style="background-color: #BDB76B" class="swatch" rel="tooltip" title="Color.darkKhaki"></div>
          <div style="background-color: #FFFACD" class="swatch" rel="tooltip" title="Color.lemonChiffon"></div>
          <div style="background-color: #EEE8AA" class="swatch" rel="tooltip" title="Color.paleGoldenrod"></div>
          <div style="background-color: #F0E68C" class="swatch" rel="tooltip" title="Color.khaki"></div>
          <div style="background-color: #FFD700" class="swatch" rel="tooltip" title="Color.gold"></div>
          <div style="background-color: #FFF8DC" class="swatch" rel="tooltip" title="Color.cornsilk"></div>
          <div style="background-color: #DAA520" class="swatch" rel="tooltip" title="Color.goldenrod"></div>
          <div style="background-color: #B8860B" class="swatch" rel="tooltip" title="Color.darkGoldenrod"></div>
          <div style="background-color: #FFFAF0" class="swatch" rel="tooltip" title="Color.floralWhite"></div>
          <div style="background-color: #FDF5E6" class="swatch" rel="tooltip" title="Color.oldLace"></div>
          <div style="background-color: #F5DEB3" class="swatch" rel="tooltip" title="Color.wheat"></div>
          <div style="background-color: #FFE4B5" class="swatch" rel="tooltip" title="Color.moccasin"></div>
          <div style="background-color: #FFA500" class="swatch" rel="tooltip" title="Color.orange"></div>
          <div style="background-color: #FFEFD5" class="swatch" rel="tooltip" title="Color.papayaWhip"></div>
        </div><div>
          <div style="background-color: #FFEBCD" class="swatch" rel="tooltip" title="Color.blanchedAlmond"></div>
          <div style="background-color: #FFDEAD" class="swatch" rel="tooltip" title="Color.navajoWhite"></div>
          <div style="background-color: #FAEBD7" class="swatch" rel="tooltip" title="Color.antiqueWhite"></div>
          <div style="background-color: #D2B48C" class="swatch" rel="tooltip" title="Color.tan"></div>
          <div style="background-color: #DEB887" class="swatch" rel="tooltip" title="Color.burlyWood"></div>
          <div style="background-color: #FFE4C4" class="swatch" rel="tooltip" title="Color.bisque"></div>
          <div style="background-color: #FF8C00" class="swatch" rel="tooltip" title="Color.darkOrange"></div>
          <div style="background-color: #FAF0E6" class="swatch" rel="tooltip" title="Color.linen"></div>
          <div style="background-color: #CD853F" class="swatch" rel="tooltip" title="Color.peru"></div>
          <div style="background-color: #FFDAB9" class="swatch" rel="tooltip" title="Color.peachPuff"></div>
          <div style="background-color: #F4A460" class="swatch" rel="tooltip" title="Color.sandyBrown"></div>
          <div style="background-color: #D2691E" class="swatch" rel="tooltip" title="Color.chocolate"></div>
          <div style="background-color: #8B4513" class="swatch" rel="tooltip" title="Color.saddleBrown"></div>
          <div style="background-color: #FFF5EE" class="swatch" rel="tooltip" title="Color.seashell"></div>
          <div style="background-color: #A0522D" class="swatch" rel="tooltip" title="Color.sienna"></div>
          <div style="background-color: #FFA07A" class="swatch" rel="tooltip" title="Color.lightSalmon"></div>
          <div style="background-color: #FF7F50" class="swatch" rel="tooltip" title="Color.coral"></div>
          <div style="background-color: #FF4500" class="swatch" rel="tooltip" title="Color.orangeRed"></div>
          <div style="background-color: #E9967A" class="swatch" rel="tooltip" title="Color.darkSalmon"></div>
          <div style="background-color: #FF6347" class="swatch" rel="tooltip" title="Color.tomato"></div>
        </div><div>
          <div style="background-color: #FFE4E1" class="swatch" rel="tooltip" title="Color.mistyRose"></div>
          <div style="background-color: #FA8072" class="swatch" rel="tooltip" title="Color.salmon"></div>
          <div style="background-color: #FFFAFA" class="swatch" rel="tooltip" title="Color.snow"></div>
          <div style="background-color: #F08080" class="swatch" rel="tooltip" title="Color.lightCoral"></div>
          <div style="background-color: #BC8F8F" class="swatch" rel="tooltip" title="Color.rosyBrown"></div>
          <div style="background-color: #CD5C5C" class="swatch" rel="tooltip" title="Color.indianRed"></div>
          <div style="background-color: #FF0000" class="swatch" rel="tooltip" title="Color.red"></div>
          <div style="background-color: #A52A2A" class="swatch" rel="tooltip" title="Color.brown"></div>
          <div style="background-color: #B22222" class="swatch" rel="tooltip" title="Color.fireBrick"></div>
          <div style="background-color: #8B0000" class="swatch" rel="tooltip" title="Color.darkRed"></div>
          <div style="background-color: #800000" class="swatch" rel="tooltip" title="Color.maroon"></div>
          <div style="background-color: #FFFFFF" class="swatch" rel="tooltip" title="Color.white"></div>
          <div style="background-color: #F5F5F5" class="swatch" rel="tooltip" title="Color.whiteSmoke"></div>
          <div style="background-color: #DCDCDC" class="swatch" rel="tooltip" title="Color.gainsboro"></div>
          <div style="background-color: #D3D3D3" class="swatch" rel="tooltip" title="Color.lightGray"></div>
          <div style="background-color: #C0C0C0" class="swatch" rel="tooltip" title="Color.silver"></div>
          <div style="background-color: #A9A9A9" class="swatch" rel="tooltip" title="Color.darkGray"></div>
          <div style="background-color: #808080" class="swatch" rel="tooltip" title="Color.gray"></div>
          <div style="background-color: #696969" class="swatch" rel="tooltip" title="Color.dimGray"></div>
          <div style="background-color: #000000" class="swatch" rel="tooltip" title="Color.black"></div>
        </div>
      </div>

      <h3>Pre-Defined Colors</h3>

      <p>
        To make as easy as possible to use colors right out of the box, Sofia's <code>Color</code> class provides 140 pre-defined colors&mdash;the same set that is defined in CSS for web development. Hover over the color swatches to the right to see the name of the constant in the <code>Color</code> class that will produce that color.
      </p><p>
        For those situations where none of these 140 colors is sufficient, the <code>Color</code> class provides a number of static <strong>factory methods</strong> that you can use to create new ones:
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th style="width: 30%">Method</th>
            <th>Effect</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><code class="link">sofia.graphics.Color#gray(int)</td>
            <td>Returns a shade of gray. The gray level passed into this method must be between 0 and 255, where 0 is black and 255 is white.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#gray(int, int)</td>
            <td>Returns a shade of gray. The first parameter is the gray level; the second parameter is the alpha component.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#rgb(int, int, int)</td>
            <td>Returns a color from its red, green, and blue components.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#rgb(int, int, int, int)</td>
            <td>Returns a color from its red, green, blue, and alpha components.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#hsv(float, float, float)</td>
            <td>Returns a color from its hue, saturation, and value components. Hue is a value between 0 and 360; saturation and value are between 0 and 1. More information about HSV color representation can be found in <a href="http://en.wikipedia.org/wiki/HSL_and_HSV">this Wikipedia article</a>.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#hsv(float, float, float, int)</td>
            <td>Returns a color from its hue, saturation, value, and alpha components.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.Color#getRandomColor()</td>
            <td>Returns a color with random red, green, and blue components. The alpha of the color returned will always be 255.</td>
          </tr>
        </tbody>
      </table>


      <div class="alert alert-info">
        <p>
          Objects that represent colors are a Sofia feature not found in Android. The traditional Android API represents colors simply as integers that combine the red, green, blue, and alpha components into a single number. Android <em>does</em> contain a <code class="link">android.graphics.Color</code> class, but you cannot create objects from it. Instead, it only provides static methods to manipulate color integers.
        </p><p>
          If you want to use Sofia <code>Color</code> objects with traditional Android APIs that expect colors to be represented as integers, you can call the <code class="link">sofia.graphics.Color#toRawColor()</code> method to return the integer representation of a <code>Color</code> object. Likewise, the <code class="link">sofia.graphics.Color#fromRawColor(int)</code> method will create a <code>Color</code> object from a color integer.
        </p>
      </div>


      <div class="page-header"><h2 id="shape-screen">Shape Screens and Shape Views</h2></div>

      <p>
        Now that we've talked about the shapes themselves, let's take a moment to discuss where they go once you create them. Recall that the <code class="link">sofia.app.Screen</code> class acts as the <strong>controller</strong> for GUI-driven applications that use a layout defined in your app's resources.
      </p><p>
        What if&mdash;instead of a GUI filled with buttons and other widgets&mdash;you just wanted to create a full-screen drawing canvas where shapes could be drawn, manipulated, and animated?
      </p><p>
        Sofia provides a <code class="link">sofia.app.ShapeScreen</code> class that does exactly this. If you extend <code>ShapeScreen</code>, then that screen in your app will automatically have a full-sized shape canvas where you can add your shapes.
      </p><p>
        As before, you should implement the <code>initialize()</code> method in your screen class to prepare what it should look like before it is displayed to the user. Consider the following example:
      </p>

      <div class="row">
        <div class="span9">
<pre>
import sofia.app.*;
import sofia.graphics.*;

public class MyScreen extends ShapeScreen
{
    public void initialize()
    {
        RectangleShape box = new RectangleShape(0, 0, 50, 50);
        box.setFilled(true);
        box.setColor(Color.red);
        add(box);
    }
}
</pre>
        </div>
        <div class="span3">
        </div>
      </div>

      <p>
        In the first three lines of the method, we created a rectangular shape positioned at (0, 0), the top-left corner of the screen, with a width and height of 50 pixels (so it is square), and made it filled with the color red. Creating the shape is not enough to display it on the screen, however. It must be <strong>added</strong> to the screen; this allows you to create shapes earlier in the program and only add them to the screen when they need to be shown, if you wish.
      </p><p>
        The <code class="link">sofia.app.ShapeScreen#add(Shape)</code> method on the last line is inherited from <code>ShapeScreen</code> and adds the shape to the screen, which refreshes the screen so that the shape is now made visible. In addition to this method, the following other methods let you manipulate shapes on the screen:
      </p>

      <table class="table table-bordered">
        <tbody>
          <tr>
            <td><code class="link">sofia.graphics.ShapeScreen#add(Shape)</td>
            <td>Adds a shape to the screen.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.ShapeScreen#remove(Shape)</td>
            <td>Removes the specified shape from the screen, causing it to no longer be drawn.</td>
          </tr>
          <tr>
            <td><code class="link">sofia.graphics.ShapeScreen#clear()</td>
            <td>Removes <strong>every</strong> shape from the screen. When it is redrawn, it will appear blank.</td>
          </tr>
        </tbody>
      </table>


      <h3>The Order of Shapes</h3>

      <p>
        Very frequently, you'll add shapes to the screen that overlap with other shapes that are already there. Shapes are drawn in the order that they are added, which means that shapes that you add later will obscure shapes that were added earlier if they overlap.
      </p><p>
        It is possible to override this behavior by modifying the <strong>z-index</strong> of a shape. You can think of the z-index as a value along an imaginary third axis that projects out of the screen toward the user. By default, all shapes have a z-index of zero. To change this value for a shape, call its <code class="link">sofia.graphics.Shape#setZIndex(int)</code> method and pass it any negative or positive integer value. Shapes with higher z-indexes will always be drawn on top of shapes with lower z-indexes, regardless of the actual order that they were added to the canvas.
      </p>


      <h3>Adjusting to Different Screen Sizes</h3>

      <p>
        There is a wide variety of Android devices on the market, both smartphones and tablets, and these devices come in many different screen sizes and resolutions. Because of this, you should <strong>never</strong> write code that assumes that the screen has a particular width or height.
      </p><p>
        Instead, you should write code that adjusts to the screen size dynamically. The <code>ShapeScreen</code> class has two methods that let you ask what the size of the screen is: <code class="link">sofia.app.ShapeScreen#getWidth()</code> returns the width of the screen in pixels, and <code class="link">sofia.app.ShapeScreen#getHeight()</code> returns its height. You can use these values to do things like anchor a shape to the right or bottom of the screen, or to create a row or column of equal sizes shapes that span the width or height of the screen.
      </p>


      <h3>Mixing Shapes with Other Widgets</h3>

      <p>
        For some kinds of apps, you may not want the shape canvas to take up the entire screen, but instead combine it with other widgets or views so that you can still make use of standard buttons and text fields.
      </p><p>
        For performance reasons, it is highly discouraged that you try to include Android widgets directly <strong>on</strong> the shape canvas itself. Instead, you can partition your screen space so that a shape canvas occupies part of your GUI layout alongside those other widgets.
      </p><p>
        The easiest way to do this is still to have your screen class extend <code>ShapeScreen</code>, but then to also provide a GUI layout XML file for the screen, either by giving it the right filename or using the <code>@ScreenLayout</code> annotation.
      </p><p>
        In this layout, you need to let Sofia know where the shape canvas should go. This canvas is actually represented by the <code class="link">sofia.graphics.ShapeView</code> class. This view is located in the <strong>Custom and Library Views</strong> section of the GUI palette and you can drag one of these onto your layout as you would any other widget.
      </p><p>
        Just placing the view on your layout isn't enough, however. Methods like <code>add()</code> from the <code>ShapeScreen</code> must still know which view actually represents the <code>ShapeView</code> that shapes should be added to. To make this connection, give the view an ID of <code>shapeView</code>, spelled exactly this way (lowercase <code>s</code>, uppercase <code>V</code>). Once this is done, the screen will find the correct view to place shapes on.
      </p>
      
      <div class="alert alert-info">
        The last paragraph above implies that a <code>ShapeScreen</code> can only manipulate one <code>ShapeView</code> at a time. You <strong>can</strong> have as many <code>ShapeView</code> objects as you want on a single screen, but only one can be manipulated using the <strong>screen's</strong> <code>add()</code>/<code>remove()</code>/<code>clear()</code> methods. However, the <code>ShapeView</code> class itself also provides these methods, so that you can manipulate other views directly if you need to.
      </div>


      <div class="page-header"><h2 id="touch-events">Handling Touch Events</h2></div>

      <p>
        We've already seen some examples of handling user input for the built-in Android widgets in <a href="chapter2.html">Chapter 2</a>. For example, when the user touches a button, your <code>Screen</code> receives a notification that it was clicked.
      </p><p>
        For buttons and other standard widgets, however, this is all the information you receive. That is, you only find out <strong>that</strong> the button was clicked, not <strong>where</strong> on the button was clicked. That's fine, though&mdash;for regular buttons, it doesn't matter whether the user tapped the left side or the right side, as long as she tapped <strong>somewhere</strong> on it.
      </p><p>
        If you're doing something more advanced though, like manipulating graphics on a canvas, detailed touch input data becomes more important. You probably want to know what location on the screen was tapped, what shapes were there, let the user drag shapes around, or any number of other possibilities.
      </p><p>
        Touch input notifications come in <strong>three phases</strong>:
      </p>

      <ol>
        <li>A single notification when the user has <strong>touched her finger down</strong> on the screen.</li>
        <li>Then, while holding it down, you may receive <strong>zero, one, or several</strong> notifications that the user has <strong>moved her finger</strong> on the screen.</li>
        <li>Finally, a single notification that the user has <strong>lifted her finger up</strong> off the screen.</li>
      </ol>

      <p>
        The fact that you receive many movement notifications is important because it allows your app to track that movement live and respond immediately. Even the slighest movement might generate a handful of events.
      </p><p>
        So how does your app handle these? If you've extended <code>ShapeScreen</code>, then you can implement any or all of the following three methods, depending on what kind of notifications you need to handle:
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Event Method</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="nowrap"><code>onTouchDown(MotionEvent event)</td>
            <td>Called once when the user first touches her finger down on the shape canvas.</td>
          </tr>
          <tr>
            <td class="nowrap"><code>onTouchMove(MotionEvent event)</td>
            <td>Called many times as the user drags her finger around the shape canvas as it is held down against the screen.</td>
          </tr>
          <tr>
            <td class="nowrap"><code>onTouchUp(MotionEvent event)</td>
            <td>Called once when the user finally lifts her finger up off the shape canvas.</td>
          </tr>
        </tbody>
      </table>

      <p>
        Each of these three methods takes a parameter that is an <code class="link">android.view.MotionEvent</code> object, which provides detailed information about the event. For most situations, the main two methods you'll be calling on this object are <code class="link">android.view.MotionEvent#getX()</code> and <code class="link">android.view.MotionEvent#getY()</code>, which return the pixel location where the event occurred (where the finger touched the screen or where it was dragged to).
      </p>

      
      <h3>Determining Which Shape Was Touched</h3>

      <p>
        For some apps, you might only interested in the pixel location where the user touched the screen. For example, and app that lets you draw shapes would want to use that precise location to position and size the shape when the user touches and drags. In these cases, the coordinates retrieved from the <code>MotionEvent</code> object provide all the information you need.
      </p><p>
        For other apps, however, existing shapes on the screen might represent touchable objects that the app should react to in different ways when the user comes in contact with them. In this case, the pixel location of the touch event is only a tool to answer the real question you're interested in: Which shape was touched?
      </p><p>
        There are two main ways of getting an answer to this question, and it depends on which of the following ways is more appropriate to ask it. The first is a simple <strong>yes/no question</strong>, and the second is a <strong>search query</strong>:
      </p>

      <ol>
        <li>You can ask a specific <code>Shape</code>, "Do you occupy a particular location on the canvas?"</li>
        <li>You can ask the <code>ShapeScreen</code> (or the <code>ShapeView</code>), "Give me the shape&mdash;or shapes&mdash;that occupy a particular location on the canvas."</li>
      </ol>

      <p>
        The first option is the simpler of the two and is useful if you already have a specific shape of interest and want to know if the user has touched it. To do this, you call the <code class="link">sofia.graphics.Shape#contains(float, float)</code> method on the <code>Shape</code> object and pass it the <i>x</i>- and <i>y</i>-coordinates of the location you're interested in. This method returns a <code>boolean</code> value: <code>true</code> if the point is inside the shape or <code>false</code> if it is not.
      </p><p>
        The second option is more useful if you have a large number of shapes on the screen and want to quickly filter the ones that the user came in contact with. <code>ShapeScreen</code> and <code>ShapeView</code> provide the following methods:
      </p>

      <table class="table table-bordered">
        <thead>
          <tr>
            <th>Method</th>
            <th>Purpose</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td class="nowrap"><code class="link">sofia.graphics.ShapeScreen#getShapeAt(float, float)</td>
            <td>Returns the <code>Shape</code> that is located at the specified <i>x-</i> and <i>y-</i>coordinates on the screen. If multiple shapes overlap at that point, the, Class frontmost one is returned. If there is no shape at that point, this method returns <code>null</code>.</td>
          </tr>
          <tr>
            <td class="nowrap"><code class="link">sofia.graphics.ShapeScreen#getShapeAt(float, float, Class)</td>
            <td>Returns the <code>Shape</code> that is located at the specified <i>x-</i> and <i>y-</i>coordinates on the screen, searching only among shapes of a particular class (and subclasses). If multiple shapes overlap at that point, the frontmost one is returned. If there is no shape at that point, this method returns <code>null</code>.</td>
          </tr>
          <tr>
            <td class="nowrap"><code class="link">sofia.graphics.ShapeScreen#getShapesAt(float, float)</td>
            <td>Returns the <code>Set</code> of <code>Shape</code> objects that are located at the specified <i>x-</i> and <i>y-</i>coordinates on the screen. If there are no shapes at that point, an empty set will be returned.</td>
          </tr>
          <tr>
            <td class="nowrap"><code class="link">sofia.graphics.ShapeScreen#getShapesAt(float, float, Class)</td>
            <td>Returns the <code>Set</code> of <code>Shape</code> objects that are located at the specified <i>x-</i> and <i>y-</i>coordinates on the screen, searching only among shapes of a particular class (and subclasses). If there is no shape at that point, an empty set will be returned.</td>
          </tr>
        </tbody>
      </table>


      <div class="page-header"><h2 id="animation">Animation</h2></div>

      <p>
        In any discussion of drawing custom graphics, the question of how those graphics can be animated often comes up. Animation in the context of traditional computer graphics can be quite difficult, involving a number of advanced topics such as <strong>timers</strong> to control the frame rate, <strong>multiple threads of execution</strong> to compute those frames in the background, and <strong>synchronization</strong> to ensure that those multiple threads share a consistent view of the state of the application.
      </p><p>
        These concepts pose a great number of issues for even experienced programmers&mdash;let alone novices&mdash;and this makes developing apps with interesting animations a significant burden.
      </p><p>
        In order to address this, Sofia provides some basic but powerful animation capabilities that eliminate this burden. The API is designed in a similar fashion to animation support provided by modern web development frameworks like jQuery and Dojo.
      </p>

      
      <h3>Animating a Shape</h3>

      <img class="figure pull-right" src="img/interpolated-animation.png"/>
      
      <p>
        Animations in Sofia are based on simple <span class="label label-info">interpolation</span>. This means that you only have to be concerned with the two endpoints of the animation: the starting state, which is defined as the current state of the shape (color, position, and so forth) when the animation begins, and the desired state when the animation ends. By using these two states, Sofia smoothly interpolates what the state of the shape should be at every frame of the animation.
      </p><p>
        Consider the example to the right. When the animation begins, the oval is filled red and positioned at the top-left corner of the view. Imagine that, in the span of one second (1000 milliseconds), you want the shape to move toward the bottom-right corner and fade to black at the same time. The right-hand side of the figure shows what five frames of the animation would look like if they were all laid on top of each other.
      </p><p>
        To demonstrate how easy animations are in Sofia, the above example could be achieved in just one line of code:
      </p>

<pre>
    oval.animate(1000).position(endX, endY).color(Color.black).play();
</pre>

      <p>
        In other words, all you have to do is tell Sofia how long you want the animation to run and what you want the shape to look like when it's over. The rest is taken care of for you!
      </p>

      <h4>A Deeper Look</h4>

      <p>
        Animations in Sofia consist of three parts:
      </p>

      <ol>
        <li>a call to the shape's <code class="link">sofia.graphics.Shape#animate(long)</code> method, followed by</li>
        <li>one or more chained properties that define the desired final state of the shape, and finally</li>
        <li>a call to the <code class="link">sofia.graphics.Shape.Animator#play()</code> method to actually set the animation in motion.</li>
      </ol>

      <p>
        Let's dissect the animation above. Assume that we have an <code>OvalShape</code> object named <code>oval</code> that is positioned at the top-left corner of the screen and filled with <code>Color.red</code>. Every shape offers an <code class="link">sofia.graphics.Shape#animate(long)</code> method that lets you define an interpolation-based animation. It takes a single parameter that indicates how long the animation should run, in milliseconds. (Using milliseconds instead of seconds gives you finer precision without worrying about rounding errors.)
      </p><p>
        So, in the previous example, we are saying that we want to animate our oval for 1000 milliseconds, or one second. After this, we list the properties that we want to have changed during the animation&mdash;specifically, we say what we want them to look like when it's over. In this example, we want the position of the object to change to the coordinates <code>(endX, endY)</code>, which we will assume to be variables defined elsewhere. So, we call the <code class="link">sofia.graphics.Shape.Animator#position(float, float)</code> method. We also want the color of the object to fade to black, so we call <code class="link">sofia.graphics.Shape.Animator#color(Color)</code>.
      </p><p>
        All this work only <strong>configures</strong> the animation&mdash;it does not start it running. To do this, we must end our animation chain with a call to the <code class="link">sofia.graphics.Shape.Animator#play()</code> method. Calling this method starts the animation in the background and <strong>returns immediately</strong>. In other words, it does not wait for the animation to complete.
      </p>


      <h3>When Shapes Collide</h3>

      <p>
        If your shape animations include movement, then at some point it's possible that your shapes might <strong>collide</strong> with each other while they're moving, or they might make contact with the edge of the screen. For games especially, it's important to be notified about such events so that you can execute some game logic in response to them&mdash;for example, by destroying one of the shapes that was hit, or reducing a player's health, or performing some other action.
      </p><p>
        Handling collisions in Sofia only requires writing one method, but there are two places where you can do it:
      </p>

      <ol>
        <li>You can write an <code>onCollisionBetween</code> method in your <code>Screen</code> subclass that gets called when two shapes collide, or when a shape collides with the edge of the screen.</li>
        <li>You can write an <code>onCollisionWith</code> method in a custom <code>Shape</code> subclass that gets called when that shape collides with another shape or with the edge of the screen.</li>
      </ol>

      <h4>Handling Collisions in the Screen Class</h4>

      <p>
        The first option is the only option you have if you're using the built-in shapes instead of extending them with classes of your own. In this case, you must write an <code>onCollisionBetween</code> method that takes two parameters: the two shapes involved in the collision.
      </p><p>
        What types should the parameters be? It depends on <strong>how broad or narrow you want your collision notifications to be.</strong> The most general option is the following:
      </p>

<pre>
    public void onCollisionBetween(Shape first, Shape second)
    {
        // Do something...
    }
</pre>

      <p>
        This method will be called whenever <strong>any</strong> two shapes collide. But what if you're only interested in collisions between specific kinds of shapes? If your app includes ovals and rectangles flying around the screen but you're only interested in when a rectangle and an oval collide, but not when rectangles or ovals collide with themselves, you can write a method with more specific parameter types:
      </p>

<pre>
    public void onCollisionBetween(RectangleShape first, OvalShape second)
    {
        // Do something...
    }
</pre>

      <p>
        Then, this method will <strong>only be called</strong> when a <code>RectangleShape</code> and an <code>OvalShape</code> collide. (The order of the two parameters does not matter.) Since this is an example of <span class="label label-info">method overloading</span>, it means you can have as many versions of the <code>onCollisionBetween</code> method as you want in your screen class, and only the appropriate one (or ones) will be called depending on the types of objects that collided.
      </p>

      
      <h4>Handling Collisions in the Shapes Themselves</h4>

      <p>
        If you extend the built-in shapes to create your own custom subclasses, then you have the more convenient option of adding collision handling logic directly to the shapes themselves. This means that logic and behavior of how that collision should be handled is all neatly organized in your data model.
      </p><p>
        Think back to the <code>Piggy</code> class in the <em>Angry Birds</em> example from earlier. When a bird and a piggy collide, you want to call the <code>gotHit()</code> method that decreases the piggy's health and changes his appearance. This logic can be written easily using the <code>onCollisionWith</code> method. Since this method is implemented in a shape itself, it assumes that one of the shapes involved in the collision is the object that the method is called on. Then, this method only needs to take one parameter: the other shape involved in the collision.
      </p>

<pre>
public class Piggy extends ImageShape
{
    // The same fields, constructors, and methods from before...

    public void onCollisionWith(Bird bird)
    {
        gotHit();
    }
}
</pre>

      <p>
        And that's it! Whenever a <code>Bird</code> collides with a <code>Piggy</code>, the method above will be called without any further intervention on your part. As with <code>onCollisionBetween</code>, you can overload <code>onCollisionWith</code> with as many different parameter types as you want in order to handle collisions between the shape class that the method is in and other kinds of shapes.
      </p>

    </div> <!-- /container -->

    <footer>
      <div class="container">
        <p class="pull-left">
          &copy; 2012 Tony Allevato
        </p>
        <p class="pull-right">
          <a href="#">Back to top</a>
        </p>
      </div>
    </footer><!-- footer -->

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7/jquery.min.js" type="text/javascript"></script>
    <script src="codemirror/lib/codemirror.js" type="text/javascript"></script>
    <script src="js/bootstrap.min.js" type="text/javascript"></script>
    <script src="js/cm.js" type="text/javascript"></script>
  </body>
</html>
